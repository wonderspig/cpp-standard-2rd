定义：
namespace std {
	template <typename T,typename Allocator = allocator<T> >
	class list;
}
list其内部结构完全不同于array,vector,deque，它内部不再是以数组为底层结构，而是节点为底层结构来实现的容器(每个节点就是容器存放的一个元素)。
list提供两个指针，一个指向第一个元素，一个指向最后一个元素。
每个元素都有一个指针指向前一个元素和后一个元素
list提供双向迭代器

list与array,vector,deque的不同：
1.list不支持随机访问。(访问任意元素的效率较低，复杂度为线性。但访问第一个元素和最后一个元素的速度很快)
2.在任何位置上安插和移除元素都非常快速。(不止是两端)，所有安插和移除都保证常量复杂度(因为无需移动任何元素，只是移动指针而已)
3.安插动作不会导致指向元素的引用，指针和迭代器失效
4.list对异常的处理方式可以保证"要么成功，要么什么也不发生"，哪怕元素的拷贝移动函数会抛出异常，也不会发生只成功一半这种尴尬的情况

list的成员函数反映出它与array,vector,deque的不同：
1.list提供：
  1.返回第一个元素
  2.压入第一个元素
  3.删除(弹出)第一个元素
  4.返回最后一个元素
  5.压入最后一个元素
  6.删除(弹出)最后一个元素
等等操作函数
2.list不支持随机访问，既没有下标[]方括号操作符，也没有at()操作函数
3.list不提供容量，空间重新分配的操作函数(无必要，每个元素自己占用一块内存，指向他们的引用，指针和迭代器在元素被删除前始终有效)
4.list提供不少特殊成员函数(用于移动的移除元素,和STL的算法同名,但是因为他们只移动指针,所效率比STL同名算法要高)

list的操作
1.创建，复制和销毁
  1.默认构造函数
  2.拷贝构造(右值拷贝构造)
  3.赋值运算符(移动赋值运算符)
  4.指定元素个数的构造函数(会调用默认构造函数为每个元素初始化)
  5.指定元素个数，和每个元素初值的构造函数
  6.指定某个区间的构造函数
  7.初值列构造函数
  8.初值列赋值运算符
  注意：和所有序列式容器一样，初值来源的详情见容器的共通能力
2.非更易型操作
  1.判空
  2.取得目前的元素个数
  3.返回元素个数的最大可能量
  4.== != > < >= <=
3.赋值
  1.普通赋值运算符
  2.移动赋值运算符
  3.初值列赋值运算符
  4.assign赋值(n个elem)
  5.assign赋值指定某个区间
  6.assign赋值初值列
  7.成员swap和非成员swap
4.元素访问
  1.可以使用for循环来进行元素访问
  2.可以通过迭代器来访问元素(list提供双向迭代器)
  3.可以使用操作函数来访问元素(只提供第一个元素和最后一个元素的访问函数)
    1.c.front()  访问list的第一个元素
    2.c.back()   访问list的最后一个元素
    注意：调用操作函数时保证容器非空时调用者的责任，否则行为不可预测
5.迭代器相关函数
  只有运用迭代器，才能访问list中的各个元素。
  list只提供双向访问迭代器(并不是随机访问)，所以无法调用sort等等需要随机访问的STL算法
  但是可以使用成员sort算法
  1.提供了指向第一个元素的迭代器: 一般迭代器，常量迭代器，反向迭代器，反向常量迭代器
  2.提供了指向最后一个元素的迭代器: 一般迭代器，常量迭代器，反向迭代器，反向常量迭代器
  注意：list在删除元素前，迭代器始终有效
6.元素的安插和移除(通用的更易型操作)
  必须保证实参合法
  1.迭代器必须指向一个合法的位置
  2.区间的起始位置不能在结束位置之后
  多个元素的安插，安插一次比安插多次效率高
  操作函数：
  1.最后压入一个元素
  2.弹出最后一个元素(不反回最后一个元素)
  3.在头部插入一个元素
  4.弹出第一个元素(不返回第一个元素)
  insert
  (所有插入函数返回新元素的位置，没有新元素则返回pos)
  5.在pos位置插入一个elem
  6.在pos位置插入n个elem
  7.在pos位置插入一个区间中的元素
  8.在pos位置插入一个初值列中的元素
  emplace
  (所有插入函数返回新元素的位置)
  9.在pos位置插入args为初值的元素
  10.在容器末尾插入args为初值的元素(不反回任何东西)
  11.在容器头部插入args为初值的元素(不反回任何东西)
  erase
  (删除元素都返回下一个元素的位置)
  12.移除pos位置上的元素
  13.移除区间中的元素
  remove
  14.移除其值等于val的元素
  15.移除造成op判断结果为true的元素
    注意：array,vector,deque都没有提供remove系列的函数(移除相同值的元素，或判断式为true的元素)
          array,vector,deque如果需要这项功能，就需要调用通用STL算法
  resize
  16.元素数量改为num(如果数量变大，多出来的元素以默认构造函数初始化)
  17.元素数改为num(如果数量变大，多出来的元素为elem)
  clear
  18.移除所有元素，容器为空
  注意：1.所有在末尾进行操作的函数，都不返回任何东西
       2.所有在头部进行操作的函数，都不返回任何东西
       3.弹出最后一个元素时，保证容器不为空是调用者的责任
       4.弹出第一个元素时，保证容器不为空是调用者的责任

list提供了deque的所有功能，还增加了remove系列函数(通用remove系列函数针对链表的特殊版本，只对指针进行操作，保证常量复杂度)
remove的用法和STL通用remove类似

效率：多个元素的安插，安插一次比安插多次效率高

通用的更易型操作不会使指向元素的引用，迭代器或指针失效
包括：insert系列，erase系列，emplace系列，头尾添加或删除(一共四个)

list的特殊更易型算法
list可以保证咋任何位置安插和删除元素，都保证常量复杂度(list的成员算法只改变指针)
为了突出这个优势，list提供了一系列特殊操作函数(不单单使remove系列)
unique
1.存在相邻且数值相同的元素，移除重复元素，只保留一个
2.存在相邻且op判断结果为true的元素，移除重复元素，只保留一个
splice
3.将c2中的所有元素转移到c中的pos处之前(c和c2不能相同)
4.将c2中的pos处的那一个元素转移到c中的pos处(c和c2可以相同)
5.将c2中的一个区间转移到c中的pos处(c和c2可以相同)
sort
6.以小于为准则，对所有元素进行排序
7.以op为true为准则对所有元素进行排序
merge
8.c和c2都已经按小于已排序，c2全部转移到c中，c仍为已排序
9.c和c2都已经按op为true已排序，c2全部转移到c中，c仍为已排序
reverse
10.反转整个链表

list的异常处理
STL容器中，list提供了对事物安全性的最佳支持
1.任何情况下要么成功，要么没有任何副作用
  1.头部压入
  2.尾部压入
  3.中间插入
  4.调整list元素数(包括多出来的元素用默认构造函数，和多出来的元素使用一个值)
2.绝对不会抛出异常
  1.弹出头部pop(删除头节点)
  2.弹出尾部pop(删除尾节点)
  3.删除中间任意节点erase
  4.清空链表
  5.splice系列(把一个链表转移到另一个链表中)
3.元素的比较动作不抛出异常，就不会抛出异常
  1.remove系列：值相同或op为true就移除
  2.unique系列：相邻值相同或相邻op为true，就只保留一个
  3.merge系列：合并两个已排序链表，合并后仍然已排序(可以用op定义排序准则)


























