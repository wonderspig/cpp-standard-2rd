定义：
namespace std {
	template <typename T,typename Allocator = allocator<T> >
	class forward_list;
}
forward_list使一个受限的list(只能向前走，不能向后走)，list没有提供的功能forward_list都不提供
但是forward_list占用的内存少，行动也略快
forward_list的所有安插动作，都属于后插(因为它只能向前走，不能向后走)
oFrward_list提供向前迭代器(不是双向迭代器)

相较已list，(只能向前走，不能向后走)有以下约束：
1.Forward_list只提供向前迭代器(不是双向迭代器)，所以不支持反向迭代器
2.不提供可以取得当前容器内元素数量的成员函数size()
3.Forward_list没有提供给指向最末元素的迭代器
  (所以类似于返回最后一个元素，删除(弹出)最后一个元素，压入最后一个元素，这些成员函数都不提供)
4.Forward_list的所有安插动作，都带_after后缀，也就是说，安插动作都是后插
5.Forward_list提供了指向第一个元素之前一个元素的迭代器(用来插入第一个元素)

除了以上差异，Forward_list的行为就像个list
1.Forward_list随机访问元素，复杂度使线性的，效率很低
2.在任何位置上安插和移除元素，速度都很快	(常量复杂度，因为只修改内部的指针)
3.对异常的处理Forward_list会保证，要么成功，要么失败
4.Forward_list也提供很多特殊的成员函数(特殊的更易型)，他们是STL通用算法的优化版本，只改变指针

Forward_list的操作
1.创建，复制和销毁
  1.默认构造函数
  2.拷贝构造(右值拷贝构造)
  3.赋值运算符(移动赋值运算符)
  4.指定元素个数的构造函数(会调用默认构造函数为每个元素初始化)
  5.指定元素个数，和每个元素初值的构造函数
  6.指定某个区间的构造函数
  7.初值列构造函数
  8.初值列赋值运算符
  注意：和所有序列式容器一样，初值来源的详情见容器的共通能力
2.非更易型操作
  1.判空
  2.返回元素个数的最大可能量
  3.== != > < >= <=
  注意：Forward_list并没有提供size()，如果需要计算元素个数，可以使用distance
  std::forward_list<int> l;
  ...
  std::cout << "l.size(): " << std::distance(l.begin(),l.end())
             << std::endl;
  distance的复杂度为线性
4.赋值
  1.普通赋值运算符
  2.移动赋值运算符
  3.初值列赋值运算符
  4.assign赋值(n个elem)
  5.assign赋值指定某个区间
  6.assign赋值初值列
  7.成员swap和非成员swap
5.元素访问
  1.可以使用for循环来进行元素访问
  2.可以通过迭代器来访问元素(list提供双向迭代器)
  3.可以使用操作函数来访问元素(只提供第一个元素的访问函数)
    1.c.front()  访问list的第一个元素
  注意：调用操作函数时保证容器非空时调用者的责任，否则行为不可预测
6.迭代器相关函数
  只有运用迭代器，才能访问list中的各个元素。
  list只提供向前访问迭代器(并不是随机访问和双向访问)，也不支持反向迭代器
  所以无法调用sort等等需要随机访问的STL算法，但是可以使用成员sort算法
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
  1.提供了指向第一个元素的迭代器: 一般迭代器，常量迭代器
  2.提供了指向最后一个元素的迭代器: 一般迭代器，常量迭代器
  3.指向第一个元素之前的一个元素的迭代器: 一般迭代器，常量迭代器
  注意：Forward_list在删除元素前，迭代器始终有效
       指向第一个元素之前的一个元素的迭代器和超尾迭代器类似，并不是一个合法的位置，对它取值会导致运行期错误
       (除了复制和赋值之外，只能对这个迭代器使用==,!=,++这些操作才合法)
7.元素的安插和移除元素
  必须保证实参合法
  1.迭代器必须指向一个合法的位置
  2.区间的起始位置不能在结束位置之后
  多个元素的安插，安插一次比安插多次效率高
  操作函数：
  1.在头部插入一个元素
  2.弹出第一个元素(不返回第一个元素)
  insert_after(pos位置后插)
  (所有插入函数返回新元素的位置，没有新元素则返回pos)
  3.在pos位置插入一个elem
  4.在pos位置插入n个elem
  5.在pos位置插入一个区间中的元素
  6.在pos位置插入一个初值列中的元素
  emplace(pos位置后插)
  (所有插入函数返回新元素的位置)
  7.在pos位置插入args为初值的元素
  8.在容器头部插入args为初值的元素(不反回任何东西)
  erase
  (删除元素都不返回任何东西，pos位置后删)
  9.移除pos位置后的元素
  10.移除区间中的元素
  remove
  11.移除其值等于val的元素
  12.移除造成op判断结果为true的元素
    注意：array,vector,deque都没有提供remove系列的函数(移除相同值的元素，或判断式为true的元素)
          array,vector,deque如果需要这项功能，就需要调用通用STL算法
  resize
  13.元素数量改为num(如果数量变大，多出来的元素以默认构造函数初始化)
  14.元素数改为num(如果数量变大，多出来的元素为elem)
  clear
  15.移除所有元素，容器为空
  注意：1.所有在头部进行操作的函数，都不返回任何东西
       2.弹出第一个元素时，保证容器不为空是调用者的责任

Forward_list只能进行后插：1.在链表头处添加元素，应该使用"指向第一个元素之前的一个元素的迭代器"
                        2.对迭代器"指向最后一个元素的后一个位置迭代器"(超尾迭代器)进行带_after后缀的操作函数进行后插，结果是未定义的，会产生运行期错误
  
Forward_list只能进行后插只能进行后插，代表你在需要指定位置进行插入的时候，"找到的当下"代表"你已经过头"
(因为想要在该处安插或删除元素，你必须改写该处的前一个元素)
因此，查找准则应该是：下一元素满足条件的当前元素
详见：forwardlistfind1.cpp(维护两个指针，一个指针负责查找，一个指针负责表示查找指针的前一个元素)

还可以使用便捷函数next()，此函数会把返回作为参数的迭代器的后一个位置，可以这样使用：
auto posBefore = list.before_begin();
for ( ; next(posBefore)!=list.end(); ++posBefore) 
{
	if (*next(posBefore) % 2 == 0) 
	{ 
		break; // element found
	} 
}

可以定义自己的算法，"满足特定值"或"满足特定条件"的元素的前一个位置
详见：findbefore.hpp

Forward_list提供的特殊更易型操作
unique
1.存在相邻且数值相同的元素，移除重复元素，只保留一个
2.存在相邻且op判断结果为true的元素，移除重复元素，只保留一个
splice_after
3.将c2中的所有元素转移到c中的pos处之后(c和c2不能相同)
4.将c2中的pos处的那一个元素转移到c中的pos处之后(c和c2可以相同)
5.将c2中的一个区间转移到c中的pos处之后(c和c2可以相同)
sort
6.以小于为准则，对所有元素进行排序
7.以op为true为准则对所有元素进行排序
merge
8.c和c2都已经按小于已排序，c2全部转移到c中，c仍为已排序
9.c和c2都已经按op为true已排序，c2全部转移到c中，c仍为已排序
reverse
10.反转整个链表


splice_after这些函数的使用实例，详见：forwardlistsplice1.cpp
注意：splice_after也是带_after后缀的函数，把超尾迭代器作为插入的位置，会引发不明确行为
fwlist.splice_after(fwlist.end(),                 //ERROR
                       fwlist,
                       fwlist.begin());

异常处理：
Forward_list的异常处理和list完全相同















