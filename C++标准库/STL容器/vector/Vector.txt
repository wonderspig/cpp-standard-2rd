定义：
namespace std {
	template <typename T,typename Allocator = allocator<T> > 
	class vector;
}
vector是一个动态数组，如果在末端添加或删除元素，vector的效率相当好
vector提供随机访问迭代器

大小和容量：
大小和容量直接关系到Vector的效率
vector关于大小的操作函数：
1.size()  //当前大小
2.empty() //判空
3.max_size() //vector可容纳最多的元素数量
4.capacity() //在不重新分配内存的情况下，可以容纳的最多元素数量
注意：1.一旦重新分配内存vector元素的所有迭代器，引用，指针全部实效
     2.重新分配内存非常耗费时间

为了避免重新分配内存
1.可以使用reserve()，来保留适当容量，避免重新分配内存
2.使用构造函数传递额外实参，来构建足够的空间
  std::vector<T> v(5);
  注意：1.构造函数会进行默认初始化的操作，导致效率不如reserve()来的高
      2.vector的reserve()函数无法用来所见容量(和string不同)

也就是说vector的容量不会缩减，所以删除元素不会使指向容器的引用，指针和迭代器失效
但是安插元素有可能使引用，指针和迭代器失效(如果导致内存重新分配)

C++11提供了v.shrink_to_fit()元素个数来缩减(根据实现不具备强制力)

C++11之前可以使用swap来缩减vector的容量: swap之后两者的容量也会互换，达到缩减容量的目的
template <typename T>
void shrinkCapacity(std::vector<T>& v)
{
	std::vector<T> tmp(v); // copy elements into a new vector
	v.swap(tmp); // swap internal vector data 
}




vector的操作
1.构建、复制和销毁
  vector的构造和析构函数
  1.默认构造
  2.拷贝构造(右值拷贝)
  3.拷贝赋值运算符(移动赋值)
  4.指定元素个数的构造函数(会调用默认构造函数为每个元素初始化)
  5.指定元素个数，和每个元素初值的构造函数
  6.指定某个区间的构造函数
  7.初值列构造函数
  8.初值列赋值运算符
2.非更易型操作
  1.判空
  2.取得目前容器元素数目
  3.取得容器最大的可能元素数
  4.取得"不重新分配空间"条件下最大可能元素数
  5.扩大元素数(扩大容量)
  6.降低容量(非强制)
  7.!= == < <= > >=
3.赋值
  1.普通赋值运算符
  2.移动赋值运算符
  3.初值列赋值运算符
  4.assign赋值(n个elem)
  5.assign赋值指定某个区间
  6.assign赋值初值列
  7.成员swap和非成员swap
4.元素访问
  1.可以使用区域for循环来访问元素
  2.可以通过迭代器来访问元素(vector提供了随机访问迭代器)
  3.使用操作函数来来访问元素
    1.[]运算符
    2.c.at()成员函数 (会抛出异常)
    3.c.front()  访问vector的第一个元素
    4.c.back()   访问vector的最后一个元素
    注意：只有at()进行范围检查，其他的都不检查
         越界错误会发生不明确行为
         对空vector调用除at()之外的三个函数，结果也是为定义的。
5.迭代器相关函数
  vector提供了随机访问迭代器
  1.提供了指向第一个元素的迭代器: 一般迭代器，常量迭代器，反向迭代器，反向常量迭代器
  2.提供了指向最后一个元素的迭代器: 一般迭代器，常量迭代器，反向迭代器，反向常量迭代器
  vector迭代器失效的情况：
  1.在vector中间安插元素，此位置之后的所有迭代器，引用，指针都失效
  2.vector的内存重新分配
6.安插和移除元素
  必须保证实参合法
  1.迭代器必须指向一个合法的位置
  2.区间的起始位置不能在结束位置之后
  安插和移除元素的函数：
  1.最后压入一个元素
  2.弹出最后一个元素(不反回最后一个元素)
  insert
  (所有插入函数返回新元素的位置，没有新元素则返回pos)
  3.在pos位置插入一个elem
  4.在pos位置插入n个elem
  5.在pos位置插入一个区间中的元素
  6.在pos位置插入一个初值列中的元素
  emplace
  (所有插入函数返回新元素的位置)
  7.在pos位置插入args为初值的元素
  8.在容器末尾插入args为初值的元素(不反回任何东西)
  erase
  (删除元素都返回下一个元素的位置)
  9.移除pos位置上的元素
  10.移除区间中的元素
  resize
  11.元素数量改为num(如果数量变大，多出来的元素以默认构造函数初始化)
  12.元素数改为num(如果数量变大，多出来的元素为elem)
  clear
  13.移除所有元素，容器为空
  注意：1.所有在末尾进行操作的函数，都不返回任何东西
       2.弹出最后一个元素时，保证容器不为空是调用者的责任

  关于效率：
  1.在容器尾部安插或移除元素
  2.容量一开始就够大
  3.所以多个元素，安插一次比安插多次效率高

  vector没有提供任何与某值相等元素移除的成员函数，有这个需要应该调用相应算法


vector当作C风格数组:
和array一样，vector也是分布在一块连续的内存中的，所以，同array一样：
&a[i] == &a[0] + i总是成立
c.data()返回的是指向数组第一个元素的指针
注意：任何时候都不要使用迭代器来表现指针

异常处理：
1.c.at()是方括号运算符的安全版本，当下标超出范围时，会抛出异常
2.vector调用的函数，标准库做出如下保证
  1.push_back()，压入最后一个元素，如果函数发生异常，函数不产生效用
  2.元素的拷贝构造和移动构造不抛出异常，那么vector的所有安插函数要么成功，要么不产生效用
  3.pop_back()绝对不抛出异常
  4.元素的拷贝构造和移动构造不抛出异常，那么vector的所有删除函数不抛出异常
  5.swap和clear绝不抛出异常
  6.元素的拷贝构造和移动构造不抛出异常，那么所有操作要么成功，要么不产生效用(类似于C struct这种类型)
  注意：析构函数不能抛出异常





























