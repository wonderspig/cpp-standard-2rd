定义：
namespace std {
	template <typename T,typename Compare = less<T>,typename Allocator = allocator<T> >
	class set;

	template <typename T,typename Compare = less<T>,typename Allocator = allocator<T> >
	class multiset;
}
set和multiset提供双向迭代器
只要遵循排序准则，任意类型都可以成为容器set和multiset
关于排序准则的定义如下：P315页
1.对于<而已，必须是"非对称"的，
2.必须是可传递的
3.必须时可自反的
4.等效传递性
注意：1.这些特性说明，不存在<=,>=这种比较准则
     2.这些特性说明，如果 x<y为否，y<x为否，那么x，y是为重复元素
       (不必再提供==运算符，但必须比较两次，才能判断元素是否重复，但第一次比较为true，也就不用比较第二次了)
     3.set和multiset的等效准则时随机但稳定的，保证安插和抹除元素都会保持等效元素的相对次序

如果用==符号对容器进行比较，容器将使用元素自身的==进行比较
这意味着，元素必须提供==运算符

标准容器底层结构为二叉树
插入set和multiset的元素都会自动进行排序(导致不能改变key值，这样会打乱原本的数据)
在set和multiset中搜索元素为对数复杂度(很高效)

如果想改变元素值，可以先删除元素，再添加元素
1.set和multiset不提供任何操作函数可以直接访问元素
2.通过迭代器访问元素，从迭代器角度看，元素时常量

set和multiset的操作：
比较准则可以定义排序规则：
1.以模板参数定义之(模板参数填写排序准则的类型，那是一个函数对象)
  一个排序准则会产生一种容器类型(不同排序准则的容器无法进行合并)
2.以构造函数参数定义之
  同一个类型可以运用不同的排序准去，排序准则的初始值或这状态也可以不同(运行期获得排序准则) 详见：setcmp1.cpp

1.创建，复制和销毁
  1.默认构造函数(空set和multiset)
  2.以排序准则op为实参，建立set和multiset(空set和multiset)
  3.拷贝构造(右值拷贝构造)
  4.赋值运算符(移动赋值运算符)
  5.指定某个区间的构造函数
  6.指定某个区间的构造函数(以op为排序准则)
  7.初值列构造函数
  8.初值列赋值运算符
2.非更易型操作
  1.返回比较准则(对key)
  2.返回比较准则(对Value)
  3.判空
  4.取得目前的元素个数
  5.返回元素个数的最大可能量
  6.== != > < >= <=
  注意：1.对容器进行比较，两个容器必须类型相同(元素和排序准则必须相同)
         比较动作是按"字典顺序"来比较一个容器是否小于另一个容器
       2.绕过要比较两个类型不同的容器，可以采用比较算法
3.特殊查找函数
  set和multiset再元素查找方面有优化设计(相比通用算法，这些操作函数拥有对数复杂度)
  1.返回元素值为val的元素个数
  2.返回元素为val的第一个元素的位置(没找到就返回超尾迭代器)
  3.返回元素为val的第一个可安插位置
  4.返回元素为val的最后一个可安插位置
  5.返回元素为val的第一个和最后一个位置(元素等于val的区间)
  如何使用3，4，5操作函数，详见：setrange1.cpp
3.赋值
  1.普通赋值运算符
  2.移动赋值运算符
  3.初值列赋值运算符
  4.成员swap和非成员swap
  注意：1.只有容器类型相同，才可以进行赋值和交换
       2.如果排序准则用构造函数定义之(会出现容器类型相同，但排序准则不同的情况)，此时赋值交换，排序准则也会被赋值和交换
4.迭代器相关函数
  1.提供了指向第一个元素的迭代器: 一般迭代器，常量迭代器，反向迭代器，反向常量迭代器
  2.提供了指向最后一个元素的迭代器: 一般迭代器，常量迭代器，反向迭代器，反向常量迭代器
  注意：1.迭代器为双向迭代器(并不是随机访问迭代器)，所以无法调用sort等等需要随机访问的STL算法
         但是可以使用成员sort算法
        2.因为从迭代器的角度看，所有元素都是常量，所以无法使用更易型算法(remove等等)
          要移除元素，只能使用成员函数
5.元素的安插和移除(通用的更易型操作)
  必须保证实参合法
  1.迭代器必须指向一个合法的位置
  2.区间的起始位置不能在结束位置之后
  多个元素的安插，安插一次比安插多次效率高

  操作函数：
  insert
  (所有插入函数返回新元素的位置)
  1.插入一个val
  2.在pos位置插入一个val(pos只是一个提示)
  3.插入一个区间中的元素(无返回值)
  4.插入一个初值列中的元素(无返回值)
  emplace
  (所有插入函数返回新元素的位置)
  5.插入args为初值的元素
  6.在pos位置插入args为初值的元素(pos只是一个提示)
  erase
  7.移除与val相等的所有元素，返回移除的元素个数
  8.移除pos位置上的元素，无返回值
  9.移除区间中的元素，无返回值
  clear
  10.移除所有元素，容器为空
  注意：插入的操作函数会保证元素的相对次序，也就是说，元素会被安插在"既有等值元素群的末尾"

  insert系列和emplace系列
  set中：
  insert系列：无pos的版本返回新元素迭代器和是否成功的bool值组成的pair
             有pos的版本只返回新元素位置
  emplace系列：无pos的版本返回新元素迭代器和是否成功的bool值组成的pair
              有pos的版本只返回新元素位置
  multiset中：
  insert系列：无pos的版本返回新元素位置
             有pos的版本只返回新元素位置
  emplace系列：无pos的版本返回新元素位置
              有pos的版本只返回新元素位置
  注意：如此的原因时因为set不允许重复元素，所以插入时可能会失败
       不管成功还是失败，此函数都会返回新元素的位置，如果失败，返回的是同值元素的位置

  拥有位置pos提示参数的插入函数，返回值与没有位置pos提示参数的一样(保证拥有通用的安插函数)

  erase系列，如果给的是值，删除的是和这个值等同的所有元素，返回删除的元素个数，set返回的不是0就是1
  如果要删除重复元素中的第一个，则应该给erase传递pos，删除当前pos指向的元素
  (并没有像序列容器一样，返回下一个元素的位置，是为了提高效率)
  (以迭代器为元素的set，调用earse会造成歧义，所以c++11重载了相关earse）
  (multiset中安插和删除都会保证元素的相对次序)

  异常处理
  set和multiset是节点为基础的容器：
  1.单元素安插时，节点构造失败，容器仍然保持原样
  2.单删除时，不会抛出异常
  3.对多元素的安插，并不保证失败时，容器仍保持原样
  4.对多元素的删除，只要排序准则不抛出异常，那么删除行为要么成功，要么无效










